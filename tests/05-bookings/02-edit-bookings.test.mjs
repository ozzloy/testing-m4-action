import { assert, expect } from "chai";

import {
  agentSignUp,
  agentCreateSpot,
  createAgent,
  createManyAgents,
  fetchCsrfToken,
  fetchManyCsrfTokens,
} from "../utils/agent-factory.mjs";
import { createUniqueBooking } from "../utils/agent-helpers.mjs";

import { apiBaseUrl } from "../utils/constants.mjs";

import { expectedUpdatedBookingKeys } from "../utils/err-helpers.mjs";

import { isDateString, isInteger } from "../utils/test-utils.mjs";

/**
 * update and return an existing booking
 *   request:
 *     endpoint:
 *       PUT /bookings/:bookingId
 *     headers:
 *       Content-Type: application/json
 *     body:
 *       ```json
 *       {
 *         "startDate": "$TODAY",
 *         "endDate": "$TOMORROW"
 *       }
 *       ```
 *   response:
 *     status code:
 *       200
 *     headers:
 *       Content-Type: application/json
 *     body:
 *       ```json
 *       {
 *         "id": 1,
 *         "spotId": 1,
 *         "userId": 2,
 *         "startDate": "2021-11-19",
 *         "endDate": "2021-11-20",
 *         "createdAt": "2021-11-19 20:39:36",
 *         "updatedAt": "2021-11-20 10:06:40"
 *       }
 *       ```
 */
describe("edit an existing booking", function () {
  let owner, renter;
  let xsrfOwner, xsrfRenter;
  let spot;
  let booking;
  let path;

  before(async function () {
    this.timeout(15000);

    [owner, renter] = createManyAgents(apiBaseUrl, 2);
    [xsrfOwner, xsrfRenter] = await fetchManyCsrfTokens([owner, renter]);
    await agentSignUp(owner, xsrfOwner);
    await agentSignUp(renter, xsrfRenter);
    spot = (await agentCreateSpot(owner, xsrfOwner)).body;
    const bookingDetails = createUniqueBooking();
    booking = (
      await renter
        .post("/spots/" + spot.id + "/bookings")
        .set("X-XSRF-TOKEN", xsrfRenter)
        .set("Accept", "application/json")
        .send(bookingDetails)
    ).body;
    path = "/bookings/" + booking.id;
  });

  it("has correct endpoint, returns 200", async function () {
    const updatedBookingDetails = createUniqueBooking();
    await renter
      .put(path)
      .set("X-XSRF-TOKEN", xsrfRenter)
      .set("Accept", "application/json")
      .send(updatedBookingDetails)
      .expect(200);
  });

  it("rejects unauthentic posers", async function () {
    const poser = createAgent(apiBaseUrl);
    const xsrfPoser = await fetchCsrfToken(poser);
    poser.put(path).set("X-XSRF-TOKEN", xsrfPoser).expect(401);
  });

  it("returns an updated booking body", async function () {
    const updatedBookingDetails = createUniqueBooking();
    const updatedBooking = (
      await renter
        .put(path)

        .set("X-XSRF-TOKEN", xsrfRenter)
        .set("Accept", "application/json")
        .send(updatedBookingDetails)
        .expect(200)
    ).body;
    expect(updatedBooking).to.have.all.keys(expectedUpdatedBookingKeys);
    const { id, spotId, userId } = updatedBooking;
    expect(isInteger(id), "new booking's id should be an integer").to.be.true;
    expect(isInteger(spotId), "new booking's spotId should be an integer").to.be
      .true;
    expect(isInteger(userId), "new booking's userId should be an integer").to.be
      .true;
    expect(id).to.equal(booking.id);
    expect(spotId).to.equal(booking.spotId);
    expect(userId).to.equal(booking.userId);

    const { startDate, endDate, createdAt, updatedAt } = updatedBooking;
    expect(isDateString(startDate), "updated booking's startDate should a date")
      .to.be.equal;
    expect(isDateString(endDate), "updated booking's endDate should a date").to
      .be.equal;
    expect(isDateString(createdAt), "updated booking's createdAt should a date")
      .to.be.equal;
    expect(isDateString(updatedAt), "updated booking's updatedAt should a date")
      .to.be.equal;
    console.log("endDate", JSON.stringify(endDate, null, 2));
  });
});

/**
 * error response: body validation errors
 *   request:
 *     endpoint:
 *       PUT /bookings/:bookingId
 *     headers:
 *       Content-Type: application/json
 *     body:
 *       ```json
 *       {
 *         "startDate": "$YESTERDAY",
 *         "endDate": "$TWODAYSAGO"
 *       }
 *       ```
 *   response:
 *     status code:
 *       400
 *     headers:
 *       Content-Type: application/json
 *     body:
 *       ```json
 *       {
 *         // (or "Validation error" if generated by Sequelize),
 *         "message": "Bad Request",
 *         "errors": {
 *           "startDate": "startDate cannot be in the past",
 *           "endDate": "endDate cannot be on or before startDate"
 *         }
 *       }
 *       ```
 */

/**
 * error response: could not find booking
 *   request:
 *     endpoint:
 *       PUT /bookings/:bookingId
 *     headers:
 *       Content-Type: application/json
 *     body:
 *       ```json
 *       {
 *         "startDate": "$YESTERDAY",
 *         "endDate": "$TWODAYSAGO"
 *       }
 *       ```
 *   response:
 *     status code:
 *       404
 *     headers:
 *       Content-Type: application/json
 *     body:
 *       ```json
 *       {
 *         "message": "Booking couldn't be found"
 *       }
 *       ```
 */

/**
 * error response: cannot edit booking that is over
 *   request:
 *     endpoint:
 *       PUT /bookings/:bookingId
 *     headers:
 *       Content-Type: application/json
 *     body:
 *       ```json
 *       {
 *         "startDate": "$YESTERDAY",
 *         "endDate": "$TWODAYSAGO"
 *       }
 *       ```
 *   response:
 *     status code:
 *       403
 *     headers:
 *       Content-Type: application/json
 *     body:
 *       ```json
 *       {
 *         "message": "Past bookings can't be modified"
 *       }
 *       ```
 */

/**
 * error response: booking conflict
 *   request:
 *     endpoint:
 *       PUT /bookings/:bookingId
 *     headers:
 *       Content-Type: application/json
 *     body:
 *       ```json
 *       {
 *         "startDate": "$YESTERDAY",
 *         "endDate": "$TWODAYSAGO"
 *       }
 *       ```
 *   response:
 *     status code:
 *       403
 *     headers:
 *       Content-Type: application/json
 *     body:
 *     ```json
 *     {
 *       "message":
 *        "Sorry, this spot is already booked for the specified dates",
 *
 *       "errors": {
 *         "startDate": "Start date conflicts with an existing booking",
 *         "endDate": "End date conflicts with an existing booking"
 *       }
 *     }
 *     ```
 */
