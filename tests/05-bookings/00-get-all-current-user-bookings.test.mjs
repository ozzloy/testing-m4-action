import { assert, expect } from "chai";

import {
  agentCreateSpot,
  agentCreateBooking,
  agentSignUp,
  createManyAgents,
  fetchManyCsrfTokens,
} from "../utils/agent-factory.mjs";
import {
  createUniqueBooking,
  getBookingOffset,
  millisecondsPerDay,
} from "../utils/agent-helpers.mjs";
import { apiBaseUrl } from "../utils/constants.mjs";
import { expectedBookingKeys } from "../utils/err-helpers.mjs";

describe("get all bookings for the current user", function () {
  let owner, renter, agentNoAuth;
  let xsrfTokenOwner, xsrfTokenRenter, xsrfTokenNoAuth;
  let spot, path;

  before(async function () {
    this.timeout(15000);
    [owner, renter, agentNoAuth] = createManyAgents(apiBaseUrl, 3);
    // create a session
    [xsrfTokenOwner, xsrfTokenRenter, xsrfTokenNoAuth] =
      await fetchManyCsrfTokens([owner, renter, agentNoAuth], 3);
    await agentSignUp(owner, xsrfTokenOwner);
    await agentSignUp(renter, xsrfTokenRenter);
    const spotResult = await agentCreateSpot(owner, xsrfTokenOwner);
    spot = spotResult.body;
    path = "/spots/" + spot.id + "/bookings";
  });

  describe("POST /spots/:spotId/bookings creates booking", function () {
    it("correct endpoint", function (done) {
      try {
        const booking = createUniqueBooking();
        renter
          .post("/spots/" + spot.id + "/bookings")
          .send(booking)
          .set("X-XSRF-TOKEN", xsrfTokenRenter)
          .set("Accept", "application/json")
          .end(function (err, res) {
            expect(err).to.not.exist;
            done();
          });
      } catch (e) {
        console.log(e);
        assert(!e, "'create booking' route failed");
      }
    });

    it("requires authentication", function (done) {
      const booking = createUniqueBooking();
      agentNoAuth
        .post("/spots/" + spot.id + "/bookings")
        .send(booking)
        .set("X-XSRF-TOKEN", xsrfTokenNoAuth)
        .set("Accept", "application/json")
        .expect(401)
        .end(function (err, res) {
          if (err) return done(err);
          return done();
        });
    });
  });

  describe("response", function () {
    it("status code 201", function (done) {
      const booking = createUniqueBooking();
      renter
        .post("/spots/" + spot.id + "/bookings")
        .send(booking)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect(201)
        .end(function (err, res) {
          expect(err).to.not.exist;
          done();
        });
    });

    it("has a body that matches the api docs", function (done) {
      const booking = createUniqueBooking();
      renter
        .post("/spots/" + spot.id + "/bookings")
        .send(booking)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect(201)
        .end(function (err, res) {
          expect(err).to.not.exist;
          const { body } = res;
          expect(body).to.include.keys(expectedBookingKeys);
          let { startDate, endDate, spotId } = body;
          startDate = new Date(startDate).toISOString().split("T")[0];
          endDate = new Date(endDate).toISOString().split("T")[0];
          expect(spotId).to.equal(spot.id);
          expect(startDate).to.equal(booking.startDate);
          expect(endDate).to.equal(booking.endDate);
          done();
        });
    });
  });

  describe("error response", function () {
    xit("incomplete booking: missing end date", function (done) {
      const bookingSansEndDate = { startDate: Date.now() };
      renter
        .post("/spots/" + spot.id + "/bookings")
        .send(bookingSansEndDate)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect(400)
        .end(function (err, res) {
          expect(err).to.not.exist;
          return done();
        });
    });
    xit("incomplete booking: missing start date", function (done) {
      const bookingSansStartDate = { endDate: Date.now() };
      renter
        .post("/spots/" + spot.id + "/bookings")
        .send(bookingSansEndDate)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect(400)
        .end(function (err, res) {
          expect(err).to.not.exist;
          return done();
        });
    });
    it("startDate cannot be in the past", function (done) {
      /**
       * Status Code: 400
       * Headers:
       *  * Content-Type: application/json
       * Body:
       *  ```json
       *  {
       *    // (or "Validation error" if generated by Sequelize),
       *    "message": "Bad Request",
       *    "errors": {
       *      "startDate": "startDate cannot be in the past",
       *      "endDate": "endDate cannot be on or before startDate"
       *    }
       *  }
       *  ```
       */
      const bookingStartsInPast = {
        startDate: new Date(Date.now() - millisecondsPerDay)
          .toISOString()
          .split("T")[0],
        endDate: new Date(Date.now() + millisecondsPerDay)
          .toISOString()
          .split("T")[0],
      };
      renter
        .post(path)
        .send(bookingStartsInPast)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect(400)
        .end(function (err, res) {
          if (err) return done(err);
          const { body } = res;
          expect(body).to.have.all.keys("message", "errors");
          const { message, errors } = body;
          expect(message).to.be.oneOf(["Validation error", "Bad Request"]);
          expect(errors).to.be.an("object").that.has.property("startDate");
          const { startDate } = errors;
          expect(startDate).to.equal("startDate cannot be in the past");
          return done();
        });
    });
    it("endDate cannot be on or before startDate", function (done) {
      const booking = {
        startDate: new Date(
          Date.now() + getBookingOffset() * millisecondsPerDay,
        )
          .toISOString()
          .split("T")[0],
        endDate: new Date(Date.now() + getBookingOffset() * millisecondsPerDay)
          .toISOString()
          .split("T")[0],
      };
      renter
        .post(path)
        .send(booking)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect(400)
        .end(function (err, res) {
          if (err) return done(err);
          const { body } = res;
          expect(body).to.have.all.keys("message", "errors");
          const { message, errors } = body;
          expect(message).to.be.oneOf(["Validation error", "Bad Request"]);
          expect(errors).to.be.an("object").that.has.property("endDate");
          const { endDate } = errors;
          expect(endDate).to.equal("endDate cannot be on or before startDate");
          return done();
        });
    });
    it("couldn't find a spot with the specified id", function (done) {
      /**
       * Status Code: 404
       * Headers:
       *  * Content-Type: application/json
       * Body:
       *  ```json
       *  {
       *    "message": "Spot couldn't be found"
       *  }
       *  ```
       */
      const booking = {
        startDate: new Date(
          Date.now() + getBookingOffset() * millisecondsPerDay,
        )
          .toISOString()
          .split("T")[0],
        endDate: new Date(
          Date.now() + (getBookingOffset() + 1) * millisecondsPerDay,
        )
          .toISOString()
          .split("T")[0],
      };
      renter
        .post("/spots/0/bookings")
        .send(booking)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect("Content-Type", /application\/json/)
        .expect(404)
        .end(function (err, res) {
          if (err) return done(err);
          const { body } = res;
          expect(body).to.have.all.keys(["message"]);
          const { message } = body;
          expect(message).to.equal("Spot couldn't be found");
          return done();
        });
    });
    /**
     * Error response: Booking conflict
     * Status Code: 403
     * Headers:
     *  * Content-Type: application/json
     * Body:
     * ```json
     * {
     *   "message": "Sorry, this spot is already booked for the specified dates",
     *   "errors": {
     *     "startDate": "Start date conflicts with an existing booking",
     *     "endDate": "End date conflicts with an existing booking"
     *   }
     * }
     * ```
     */
    it("start date within extant booking", function (done) {
      const extantBooking = createUniqueBooking();
      // make a booking
      renter
        .post(path)
        .send(extantBooking)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .end(function (err, res) {
          // attempt to make a new booking who's start date
          // is inside the extant booking
          let newEndDate = new Date(extantBooking.endDate);
          newEndDate.setDate(newEndDate.getDate() + 1);
          newEndDate = newEndDate.toISOString().split("T")[0];

          const conflictingBooking = {
            startDate: extantBooking.endDate,
            endDate: newEndDate,
          };

          renter
            .post(path)
            .send(conflictingBooking)
            .set("X-XSRF-TOKEN", xsrfTokenRenter)
            .set("Accept", "application/json")
            .expect("Content-Type", /application\/json/)
            .end(function (err, res) {
              if (err) return done(err);
              const { body } = res;
              expect(body).to.have.all.keys(["message", "errors"]);
              const { message, errors } = body;
              expect(message).to.equal(
                "Sorry, this spot is already booked for the specified dates",
              );
              expect(errors).to.have.all.keys(["startDate"]);
              const { startDate } = errors;
              expect(startDate).to.equal(
                "Start date conflicts with an existing booking",
              );
              return done();
            });
        });
    });
    xit("end date within extant booking", function (done) {
      done();
    });
    xit("extant booking inside new booking", function (done) {
      done();
    });
    xit("new booking inside extant booking", function (done) {
      done();
    });
    xit("owner can't book their own spot", function (done) {
      done();
    });
  });
});
