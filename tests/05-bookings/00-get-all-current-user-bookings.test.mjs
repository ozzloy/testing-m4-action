import { assert, expect } from "chai";

import {
  agentCreateSpot,
  agentCreateBooking,
  agentSignUp,
  createManyAgents,
  fetchManyCsrfTokens,
} from "../utils/agent-factory.mjs";
import {
  createUniqueBooking,
  getBookingOffset,
  millisecondsPerDay,
} from "../utils/agent-helpers.mjs";
import { apiBaseUrl } from "../utils/constants.mjs";
import { expectedBookingKeys } from "../utils/err-helpers.mjs";

describe("get all bookings for the current user", function () {
  let owner, renter, agentNoAuth;
  let xsrfTokenOwner, xsrfTokenRenter, xsrfTokenNoAuth;
  let spot, path;

  before(async function () {
    this.timeout(15000);
    [owner, renter, agentNoAuth] = createManyAgents(apiBaseUrl, 3);
    // create a session
    [xsrfTokenOwner, xsrfTokenRenter, xsrfTokenNoAuth] =
      await fetchManyCsrfTokens([owner, renter, agentNoAuth], 3);
    await agentSignUp(owner, xsrfTokenOwner);
    await agentSignUp(renter, xsrfTokenRenter);
    const spotResult = await agentCreateSpot(owner, xsrfTokenOwner);
    spot = spotResult.body;
  });

  describe("POST /spots/:spotId/bookings creates booking", function () {
    it("correct endpoint", function (done) {
      try {
        const booking = createUniqueBooking();
        renter
          .post("/spots/" + spot.id + "/bookings")
          .send(booking)
          .set("X-XSRF-TOKEN", xsrfTokenRenter)
          .set("Accept", "application/json")
          .end(function (err, res) {
            expect(err).to.not.exist;
            done();
          });
      } catch (e) {
        console.log(e);
        assert(!e, "'create booking' route failed");
      }
    });

    it("requires authentication", function (done) {
      const booking = createUniqueBooking();
      agentNoAuth
        .post("/spots/" + spot.id + "/bookings")
        .send(booking)
        .set("X-XSRF-TOKEN", xsrfTokenNoAuth)
        .set("Accept", "application/json")
        .expect(401)
        .end(function (err, res) {
          if (err) return done(err);
          return done();
        });
    });
  });

  describe("response", function () {
    it("status code 201", function (done) {
      const booking = createUniqueBooking();
      renter
        .post("/spots/" + spot.id + "/bookings")
        .send(booking)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect(201)
        .end(function (err, res) {
          expect(err).to.not.exist;
          done();
        });
    });

    it("has a body that matches the api docs", function (done) {
      const booking = createUniqueBooking();
      renter
        .post("/spots/" + spot.id + "/bookings")
        .send(booking)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect(201)
        .end(function (err, res) {
          expect(err).to.not.exist;
          const { body } = res;
          expect(body).to.include.keys(expectedBookingKeys);
          let { startDate, endDate, spotId } = body;
          startDate = new Date(startDate).toISOString().split("T")[0];
          endDate = new Date(endDate).toISOString().split("T")[0];
          expect(spotId).to.equal(spot.id);
          expect(startDate).to.equal(booking.startDate);
          expect(endDate).to.equal(booking.endDate);
          done();
        });
    it("startDate cannot be in the past", function (done) {
      /**
       * Status Code: 400
       * Headers:
       *  * Content-Type: application/json
       * Body:
       *  ```json
       *  {
       *    // (or "Validation error" if generated by Sequelize),
       *    "message": "Bad Request",
       *    "errors": {
       *      "startDate": "startDate cannot be in the past",
       *      "endDate": "endDate cannot be on or before startDate"
       *    }
       *  }
       *  ```
       */
      const bookingStartsInPast = {
        startDate: new Date(Date.now() - millisecondsPerDay)
          .toISOString()
          .split("T"),
        endDate: new Date(Date.now() + millisecondsPerDay),
      };
      renter
        .post(path)
        .send(bookingStartsInPast)
        .set("X-XSRF-TOKEN", xsrfTokenRenter)
        .set("Accept", "application/json")
        .expect(400)
        .end(function (err, res) {
          if (err) return done(err);
          const { body } = res;
          expect(body).to.have.all.keys("message", "errors");
          const { message, errors } = body;
          expect(message).to.be.oneOf(["Validation error", "Bad Request"]);
          expect(errors).to.be.an("object").that.has.property("startDate");
          const { startDate } = errors;
          expect(startDate).to.equal("startDate cannot be in the past");
          return done();
        });
    });
    xit("endDate cannot be on or before startDate", function (done) {
      done();
    });
    xit("couldn't find a spot with the specified id", function (done) {
      /**
       * Status Code: 404
       * Headers:
       *  * Content-Type: application/json
       * Body:
       *  ```json
       *  {
       *    "message": "Spot couldn't be found"
       *  }
       *  ```
       */
      done();
    });
    /**
     * Error response: Booking conflict
     * Status Code: 403
     * Headers:
     *  * Content-Type: application/json
     * Body:
     * ```json
     * {
     *   "message": "Sorry, this spot is already booked for the specified dates",
     *   "errors": {
     *     "startDate": "Start date conflicts with an existing booking",
     *     "endDate": "End date conflicts with an existing booking"
     *   }
     * }
     * ```
     */
    xit("start date within extant booking", function (done) {
      done();
    });
    xit("end date within extant booking", function (done) {
      done();
    });
    xit("extant booking inside new booking", function (done) {
      done();
    });
    xit("new booking inside extant booking", function (done) {
      done();
    });
    xit("owner can't book their own spot", function (done) {
      done();
    });
  });
});
